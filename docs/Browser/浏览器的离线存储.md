---
title: 浏览器的离线存储
order: 5
toc: content
# nav:
#   path: /frontend
#   title: 前端
#   order: 1
# group:
#   path: /work
#   title: 事件
#   order: 3
---

## 概述

目前常见的浏览器离线存储的方式如下：

- Cookie
- Web Storage
- WebSQL
- IndexedDB
- File System

## _WebSQL_

_WebSQL_ 数据库 _API_ 并不是 _HTML5_ 规范的一部分，但是它是一个独立的规范，引入了一组使用 _SQL_ 操作客户端数据库的 _APIs_。

如果你之前接触过诸如像 _MySQL_ 这样的关系型数据库，学习过 _SQL_ 语言，那么 _WebSQL_ 对于你来讲没有任何的难度。

最新版的 _Safari, Chrome_ 和 _Opera_ 浏览器都支持 _WebSQL_。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015120.png" alt="image-20211130142613099" style="zoom:50%;" />

在 _WebSQL_ 中，有 _3_ 个核心方法：

- _openDatabase_：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。

- _transaction_：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。

- _executeSql_：这个方法用于执行实际的 _SQL_ 查询。

### 打开数据库

我们可以使用 _openDatabase( )_ 方法来打开已存在的数据库，如果数据库不存在，则会创建一个新的数据库，使用代码如下：

```js
var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
```

在上面的代码中，我们尝试打开一个名为 _mydb_ 的数据库，因为第一次不存在此数据库，所以会创建该数据库，版本号为 _1.0_，大小为 _2M_。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015135.png" alt="image-20211130142639596" style="zoom:50%;" />

_openDatabase( )_ 方法对应的 _5_ 个参数：

- 数据库名称

- 版本号

- 描述文本

- 数据库大小

- 创建回调

第 _5_ 个参数，创建回调会在创建数据库后被调用。

### 执行操作

执行操作使用 _database.transaction( )_ 函数：

```js
var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
db.transaction(function (tx) {
  tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
});
```

上面的语句执行后会在 '_mydb_' 数据库中创建一个名为 _LOGS_ 的表。

该表存在 _2_ 个字段 _id_ 和 _log_，其中 _id_ 是唯一的。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015142.png" alt="image-20211130142711069" style="zoom:50%;" />

### 插入数据

在执行上面的创建表语句后，我们可以插入一些数据：

```js
var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
db.transaction(function (tx) {
  tx.executeSql('CREATE TABLE IF NOT EXISTS STU (id unique, name, age)');
  tx.executeSql('INSERT INTO STU (id, name, age) VALUES (1, "张三", 18)');
  tx.executeSql('INSERT INTO STU (id, name, age) VALUES (2, "李四", 20)');
});
```

在上面的代码中，我们创建了一张名为 _STU_ 的表，该表存在 _3_ 个字段 _id，name_ 和 _age_。

之后我们往这张表中插入了 _2_ 条数据。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-15151.png" alt="image-20211130142729393" style="zoom:67%;" />

我们也可以使用动态值来插入数据：

```js
var stuName = '谢杰';
var stuAge = 18;
var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
db.transaction(function (tx) {
  tx.executeSql('CREATE TABLE IF NOT EXISTS STU (id unique, name, age)');
  // tx.executeSql('INSERT INTO STU (id, name, age) VALUES (1, "张三", 18)');
  // tx.executeSql('INSERT INTO STU (id, name, age) VALUES (2, "李四", 20)');
  tx.executeSql('INSERT INTO STU (id, name, age) VALUES (3, ?, ?)', [stuName, stuAge]);
});
```

在上面的代码中，我们使用动态值的方式插入了一条数据，实例中的 _stuName_ 和 _stuAge_ 是外部变量，_executeSql_ 会映射数组参数中的每个条目给 "?"。

> 注意：由于上一次操作已经插入了 _id_ 为 _1_ 和 _2_ 的数据，所以这一次插入内容时，要将前面两次插入语句注释调，否则插入操作不会成功。因为这里是一个事务，前面失败了会导致后面也失败。

### 读取数据

以下实例演示了如何读取数据库中已经存在的数据：

```html
<div id="status"></div>
```

```js
var stuName = '谢杰';
var stuAge = 18;
// 打开数据库
var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);
// 插入数据
db.transaction(function (tx) {
  tx.executeSql('CREATE TABLE IF NOT EXISTS STU (id unique, name, age)');
  tx.executeSql('INSERT INTO STU (id, name, age) VALUES (1, "张三", 18)');
  tx.executeSql('INSERT INTO STU (id, name, age) VALUES (2, "李四", 20)');
  tx.executeSql('INSERT INTO STU (id, name, age) VALUES (3, ?, ?)', [stuName, stuAge]);
});

// 读取操作
db.transaction(function (tx) {
  tx.executeSql(
    'SELECT * FROM STU',
    [],
    function (tx, results) {
      var len = results.rows.length,
        i;
      msg = '<p>查询记录条数: ' + len + '</p>';
      document.querySelector('#status').innerHTML += msg;

      for (i = 0; i < len; i++) {
        msg = '<p><b>' + results.rows.item(i).name + ':' + results.rows.item(i).age + '</b></p>';
        document.querySelector('#status').innerHTML += msg;
      }
    },
    null,
  );
});
```

在上面的代码中，第二个部分是读取数据的操作。这里我们仍然是使用的 _executeSql( )_ 方法来执行的 _SQL_ 命令，但是用法又不一样了。是时候来看一下完整的 _executeSql( )_ 方法是什么样了。

```js
executeSql(sqlStatement, arguments, callback, errorCallback);
```

该方法完整的语法实际上是接收 _4_ 个参数，分别是：

- _SQL_ 语句
- 参数
- 执行 _SQL_ 语句后的回调
- 错误回调

因此在上面的示例中，我们 _executeSql( )_ 的第三个参数就是执行了 _SQL_ 语句后的回调。我们在回调中可以通过 _results.rows_ 拿到该表中的数据，之后对数据进行业务需求的操作即可。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015159.png" alt="image-20211130142755739" style="zoom:50%;" />

### 删除数据

删除数据也是使用 _SQL_ 中的语法，同样也支持动态指定的方式。

```js
var stuID = 2;
// 删除操作
db.transaction(function (tx) {
  tx.executeSql('DELETE FROM STU  WHERE id=1');
  tx.executeSql('DELETE FROM STU WHERE id=?', [stuID]);
});
```

在上面的代码中，我们删除了 _id_ 为 _1_ 和 _2_ 的两条数据，其中第二条是动态指定的。

### 修改数据

要修改数据也是使用 _SQL_ 中的语法，同样也支持动态指定的方式。

```js
var stuID = 3;
// 更新操作
db.transaction(function (tx) {
  tx.executeSql("UPDATE STU SET name='王羲之' WHERE id=3");
  tx.executeSql('UPDATE STU SET age=21 WHERE id=?', [stuID]);
});
```

在上面的代码中，我们修改了 _id_ 为 _3_ 的学生，名字修改为“王羲之”，年龄修改为 _21_。

### 总结

目前来看，_WebSQL_ 已经不再是 _W3C_ 推荐规范，官方也已经不再维护了。原因说的很清楚，当前的 _SQL_ 规范采用 _SQLite_ 的 _SQL_ 方言，而作为一个标准，这是不可接受的。

另外，_WebSQL_ 使用 _SQL_ 语言来进行操作，更像是一个关系型数据库，而 _IndexedDB_ 则更像是一个 _NoSQL_ 数据库， 这也是目前 _W3C_ 强推的浏览端数据库解决方案。

所以本文不再对 _WebSQL_ 做过多的介绍。

如果有兴趣的同学，可以参阅下面的资料进行扩展阅读：

- _View Web SQL data_：*https://developer.chrome.com/docs/devtools/storage/websql/?utm_source=devtools#run*（需要搭梯子）
- _CSDN WebSQL_ 最全详解：*https://blog.csdn.net/weixin_45389633/article/details/107308968*

---

## _IndexedDB_

本文主要包含以下内容：

- _IndexedDB_ 简介
- _IndexedDB_ 重要概念
- _IndexedDB_ 实操
  - 操作数据库
  - 插入数据
  - 读取数据
  - 更新数据
  - 删除数据

## _IndexedDB_ 简介

随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。

现有的浏览器数据储存方案，都不适合储存大量数据：_Cookie_ 的大小不超过 _4KB_，且每次请求都会发送回服务器；_LocalStorage_ 在 _2.5MB_ 到 _10MB_ 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 _IndexedDB_ 诞生的背景。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015214.png" alt="image-20211201094954024" style="zoom:50%;" />

_MDN_ 官网是这样解释 _IndexedDB_ 的：

> _IndexedDB_ 是一种底层 _API_，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（_blobs_））。该 _API_ 使用索引实现对数据的高性能搜索。虽然 _Web Storage_ 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 _IndexedDB_ 提供了这种场景的解决方案。

通俗地说，_IndexedDB_ 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。_IndexedDB_ 允许储存大量数据，提供查找接口，还能建立索引。这些都是 _LocalStorage_ 所不具备的。就数据库类型而言，_IndexedDB_ 不属于关系型数据库（不支持 _SQL_ 查询语句），更接近 _NoSQL_ 数据库。

下表罗列出了几种常见的客户端存储方式的对比：

|  | 会话期 Cookie | 持久性 Cookie | sessionStorage | localStorage | IndexedDB | WebSQL |
| --- | --- | --- | --- | --- | --- | --- |
| 存储大小 | 4kb | 4kb | 2.5~10MB | 2.5~10MB | >250MB | 已废弃 |
| 失效时间 | 浏览器关闭自动清除 | 设置过期时间，到期后清除 | 浏览器关闭后清除 | 永久保存（除非手动清除） | 手动更新或删除 | 已废弃 |

_IndexedDB_ 具有以下特点。

- 键值对储存：_IndexedDB_ 内部采用对象仓库（ _object store_ ）存放数据。所有类型的数据都可以直接存入，包括 _JavaScript_ 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。

- 异步：_IndexedDB_ 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 _LocalStorage_ 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。

- 支持事务：_IndexedDB_ 支持事务（ _transaction_ ），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。这和 _MySQL_ 等数据库的事务类似。

- 同源限制：_IndexedDB_ 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。

- 储存空间大：这是 _IndexedDB_ 最显著的特点之一。_IndexedDB_ 的储存空间比 _LocalStorage_ 大得多，一般来说不少于 _250MB_，甚至没有上限。

- 支持二进制储存：_IndexedDB_ 不仅可以储存字符串，还可以储存二进制数据（_ArrayBuffer_ 对象和 _Blob_ 对象）。

_IndexedDB_ 主要使用在于客户端需要存储大量的数据的场景下：

- 数据可视化等界面，大量数据，每次请求会消耗很大性能。

- 即时聊天工具，大量消息需要存在本地。

- 其它存储方式容量不满足时，不得已使用 _IndexedDB_

## _IndexedDB_ 重要概念

在正式开始之前，我们先来介绍一下 _IndexedDB_ 里面一些重要的概念。

_IndexedDB_ 是一个比较复杂的 _API_，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 _API_，就是学习它的各种对象接口。

- 数据库：_IDBDatabase_ 对象

- 对象仓库：_IDBObjectStore_ 对象

- 索引：_IDBIndex_ 对象

- 事务：_IDBTransaction_ 对象

- 操作请求：_IDBRequest_ 对象

- 指针：_IDBCursor_ 对象

- 主键集合：_IDBKeyRange_ 对象

下面是一些主要的概念。

（1）数据库

数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。

_IndexedDB_ 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。

（2）对象仓库

每个数据库包含若干个对象仓库（ _object store_ ）。它类似于关系型数据库的表格。

（3）数据记录

对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。

```js
{ id: 1, text: 'foo' }
```

上面的对象中，_id_ 属性可以当作主键。

数据体可以是任意数据类型，不限于对象。

（4）索引

为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。

在关系型数据库当中也有索引的概念，我们可以给对应的表字段添加索引，以便加快查找速率。在 _IndexedDB_ 中同样有索引，我们可以在创建 _store_ 的时候同时创建索引，在后续对 _store_ 进行查询的时候即可通过索引来筛选，给某个字段添加索引后，在后续插入数据的过成功，索引字段便不能为空。

（5）事务

数据记录的读写和删改，都要通过事务完成。事务对象提供 _error、abort_ 和 _complete_ 三个事件，用来监听操作结果。

（6）指针（游标）游标是 _IndexedDB_ 数据库新的概念，大家可以把游标想象为一个指针，比如我们要查询满足某一条件的所有数据时，就需要用到游标，我们让游标一行一行的往下走，游标走到的地方便会返回这一行数据，此时我们便可对此行数据进行判断，是否满足条件。

## _IndexedDB_ 实操

_IndexedDB_ 所有针对仓库的操作都是基于事务的。

在正式开始之前，我们先创建如下的项目结构：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015307.png" alt="image-20211201095256757" style="zoom:50%;" />

该项目目录下存在 _2_ 个文件，其中 _db.js_ 是用来封装各种数据库操作的。

### 操作数据库

首先第一步是创建以及连接数据库。

_db.js_

```js
/**
 * 打开数据库
 * @param {object} dbName 数据库的名字
 * @param {string} storeName 仓库名称
 * @param {string} version 数据库的版本
 * @return {object} 该函数会返回一个数据库实例
 */
function openDB(dbName, version = 1) {
  return new Promise((resolve, reject) => {
    var db; // 存储创建的数据库
    // 打开数据库，若没有则会创建
    const request = indexedDB.open(dbName, version);

    // 数据库打开成功回调
    request.onsuccess = function (event) {
      db = event.target.result; // 存储数据库对象
      console.log('数据库打开成功');
      resolve(db);
    };

    // 数据库打开失败的回调
    request.onerror = function (event) {
      console.log('数据库打开报错');
    };

    // 数据库有更新时候的回调
    request.onupgradeneeded = function (event) {
      // 数据库创建或升级的时候会触发
      console.log('onupgradeneeded');
      db = event.target.result; // 存储数据库对象
      var objectStore;
      // 创建存储库
      objectStore = db.createObjectStore('stu', {
        keyPath: 'stuId', // 这是主键
        autoIncrement: true, // 实现自增
      });
      // 创建索引，在后面查询数据的时候可以根据索引查
      objectStore.createIndex('stuId', 'stuId', { unique: true });
      objectStore.createIndex('stuName', 'stuName', { unique: false });
      objectStore.createIndex('stuAge', 'stuAge', { unique: false });
    };
  });
}
```

在上面的代码中，我们封装了一个 _openDB_ 的函数，该函数调用 _indexedDB.open_ 方法来尝试打开一个数据库，如果该数据库不存在，就会创建。

_indexedDB.open_ 方法返回一个对象，我们在这个对象上面分别监听了成功、错误以及更新这三个事件。

这里尤其要说一下 _upgradeneeded_ 更新事件。该事件会在数据库发生更新时触发，什么叫做数据库有更新时呢？就是添加或删除表，以及数据库版本号更新的时候。

因为一开始创建数据库时，版本是从无到有，所以也会触发这个事件。

_index.html_

```html
<body>
  <script src="./db.js"></script>
  <script>
    openDB('stuDB', 1);
  </script>
</body>
```

在 _index.html_ 文件中，我们引入了 _db.js_，然后调用了 _openDB_ 方法，效果如下图所示。

![image-20211201095341185](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015341.png)

使用完数据库后，建议关闭数据库，以节约资源。

```js
/**
 * 关闭数据库
 * @param {object} db 数据库实例
 */
function closeDB(db) {
  db.close();
  console.log('数据库已关闭');
}
```

如果要删除数据库，可以使用 _indexDB_ 的 _deleteDatabase_ 方法即可。

```js
/**
 * 删除数据库
 * @param {object} dbName 数据库名称
 */
function deleteDBAll(dbName) {
  console.log(dbName);
  let deleteRequest = window.indexedDB.deleteDatabase(dbName);
  deleteRequest.onerror = function (event) {
    console.log('删除失败');
  };
  deleteRequest.onsuccess = function (event) {
    console.log('删除成功');
  };
}
```

### 插入数据

接下来是插入数据，我们仍然封装一个 _addData_ 方法，代码如下：

```js
/**
 * 新增数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} data 数据
 */
function addData(db, storeName, data) {
  var request = db
    .transaction([storeName], 'readwrite') // 事务对象 指定表格名称和操作模式（"只读"或"读写"）
    .objectStore(storeName) // 仓库对象
    .add(data);

  request.onsuccess = function (event) {
    console.log('数据写入成功');
  };

  request.onerror = function (event) {
    console.log('数据写入失败');
  };
}
```

_IndexedDB_ 插入数据需要通过事务来进行操作，插入的方法也很简单，利用 _IndexedDB_ 提供的 _add_ 方法即可，这里我们同样将插入数据的操作封装成了一个函数，接收三个参数，分别如下：

- _db_：在创建或连接数据库时，返回的 _db_ 实例，需要那个时候保存下来。
- _storeName_：仓库名称(或者表名)，在创建或连接数据库时我们就已经创建好了仓库。
- _data_：需要插入的数据，通常是一个对象。

接下来我们在 _index.html_ 中来测试。

```html
<body>
  <script src="./db.js"></script>
  <script>
    openDB('stuDB', 1).then((db) => {
      addData(db, 'stu', { stuId: 1, stuName: '谢杰', stuAge: 18 });
      addData(db, 'stu', { stuId: 2, stuName: '雅静', stuAge: 20 });
      addData(db, 'stu', { stuId: 3, stuName: '谢希之', stuAge: 4 });
    });
  </script>
</body>
```

效果如下：

![image-20211201095402192](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015402.png)

> 注意：插入的数据是一个对象，而且必须包含我们声明的索引键值对。

### 读取数据

读取数据根据需求的不同有不同的读取方式。

### 通过主键读取数据

```js
/**
 * 通过主键读取数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} key 主键值
 */
function getDataByKey(db, storeName, key) {
  return new Promise((resolve, reject) => {
    var transaction = db.transaction([storeName]); // 事务
    var objectStore = transaction.objectStore(storeName); // 仓库对象
    var request = objectStore.get(key); // 通过主键获取数据

    request.onerror = function (event) {
      console.log('事务失败');
    };

    request.onsuccess = function (event) {
      console.log('主键查询结果: ', request.result);
      resolve(request.result);
    };
  });
}
```

在我在仓库对象上面调用 _get_ 方法从而通过主键获取数据。

_index.html_

```html
<body>
  <script src="./db.js"></script>
  <script>
    openDB('stuDB', 1)
      .then((db) => {
        addData(db, 'stu', { stuId: 1, stuName: '谢杰', stuAge: 18 });
        addData(db, 'stu', { stuId: 2, stuName: '雅静', stuAge: 20 });
        addData(db, 'stu', { stuId: 3, stuName: '谢希之', stuAge: 4 });
        return getDataByKey(db, 'stu', 2);
      })
      .then((stuInfo) => {
        console.log(stuInfo); // {stuId: 2, stuName: '雅静', stuAge: 20}
      });
  </script>
</body>
```

在 _index.html_ 中进行测试，调用上面封装的 _getDataByKey_ 方法，可以看到返回了主键 _stuId_ 为 _2_ 的学生数据。

仓库对象也提供了 _getAll_ 方法， 能够查询整张表的数据内容。

_db.js_

```js
/**
 * 通过主键读取数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} key 主键值
 */
function getDataByKey(db, storeName, key) {
    return new Promise((resolve, reject) => {
        ...
        var request = objectStore.getAll(); // 通过主键获取数据
        ...
    });
}
```

在 _index.html_ 中调用方法时就需要再传递第三个参数作为 _key_ 了。

```js
openDB('stuDB', 1)
  .then((db) => {
    addData(db, 'stu', { stuId: 1, stuName: '谢杰', stuAge: 18 });
    addData(db, 'stu', { stuId: 2, stuName: '雅静', stuAge: 20 });
    addData(db, 'stu', { stuId: 3, stuName: '谢希之', stuAge: 4 });
    return getDataByKey(db, 'stu');
  })
  .then((stuInfo) => {
    console.log(stuInfo); // 会查询到该表的所有数据
  });
```

还可以通过指针来进行查询，例如：

```js
/**
 * 通过游标读取数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 */
function cursorGetData(db, storeName) {
  return new Promise((resolve, reject) => {
    let list = [];
    var store = db
      .transaction(storeName, 'readwrite') // 事务
      .objectStore(storeName); // 仓库对象
    var request = store.openCursor(); // 指针对象
    // 游标开启成功，逐行读数据
    request.onsuccess = function (e) {
      var cursor = e.target.result;
      if (cursor) {
        // 必须要检查
        list.push(cursor.value);
        cursor.continue(); // 遍历了存储对象中的所有内容
      } else {
        resolve(list);
      }
    };
  });
}
```

在上面的代码中，我们通过仓库对象的 _openCursor_ 方法开启了一个指针，这个指针会指向数据表的第一条数据，之后指针逐项进行偏移从而遍历整个数据表。

所以每次偏移拿到数据后，我们 _push_ 到 _list_ 数组里面，如果某一次没有拿到数据，说明已经读取完了所有的数据，那么我们就返回 _list_ 数组。

_indx.html_

```js
openDB('stuDB', 1)
  .then((db) => {
    addData(db, 'stu', { stuId: 1, stuName: '谢杰', stuAge: 18 });
    addData(db, 'stu', { stuId: 2, stuName: '雅静', stuAge: 20 });
    addData(db, 'stu', { stuId: 3, stuName: '谢希之', stuAge: 4 });
    return cursorGetData(db, 'stu');
  })
  .then((stuInfo) => {
    console.log(stuInfo);
  });
```

目前为止，我们的精准查询只能通过主键来进行查询。但是更多的场景是我们压根儿就不知道某一条数据的主键。例如我们要查询学生姓名为“张三”的学生数据，对于我们来讲，我们知道的信息只有学生姓名“张三”。

此时我们就可以通过索引来查询数据。

_db.js_

```js
/**
 * 通过索引读取数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} indexName 索引名称
 * @param {string} indexValue 索引值
 */
function getDataByIndex(db, storeName, indexName, indexValue) {
  return new Promise((resolve, reject) => {
    var store = db.transaction(storeName, 'readwrite').objectStore(storeName);
    var request = store.index(indexName).get(indexValue);
    request.onerror = function () {
      console.log('事务失败');
    };
    request.onsuccess = function (e) {
      var result = e.target.result;
      resolve(result);
    };
  });
}
```

在上面的方法中，我们通过仓库对象的 _index_ 方法传入了索引名称，然后链式调用 _get_ 方法传入索引的值来得到最终的查询结果。

_index.html_

```js
openDB('stuDB', 1)
  .then((db) => {
    addData(db, 'stu', { stuId: 4, stuName: '牛牛', stuAge: 4 });
    return getDataByIndex(db, 'stu', 'stuAge', 4);
  })
  .then((stuInfo) => {
    console.log(stuInfo); // {stuId: 3, stuName: '谢希之', stuAge: 4}
  });
```

在 _index.html_ 中我们新增了一条数据，年龄也为 _4_，当前的数据库表信息如下：

![image-20211201095425944](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015426.png)

但是很奇怪的是我们查询出来的数据却只有第一条符合要求的。

如果我们想要查询出索引中满足某些条件的所有数据，可以将索引和游标结合起来。

_db.js_

```js
/**
 * 通过索引和游标查询记录
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} indexName 索引名称
 * @param {string} indexValue 索引值
 */
function cursorGetDataByIndex(db, storeName, indexName, indexValue) {
  return new Promise((resolve, reject) => {
    let list = [];
    var store = db.transaction(storeName, 'readwrite').objectStore(storeName); // 仓库对象
    var request = store
      .index(indexName) // 索引对象
      .openCursor(IDBKeyRange.only(indexValue)); // 指针对象
    request.onsuccess = function (e) {
      var cursor = e.target.result;
      if (cursor) {
        // 必须要检查
        list.push(cursor.value);
        cursor.continue(); // 遍历了存储对象中的所有内容
      } else {
        resolve(list);
      }
    };
    request.onerror = function (e) {};
  });
}
```

在上面的方法中，我们仍然是使用仓库对象的 _index_ 方法进行索引查询，但是之后链式调用的时候不再是使用 _get_ 方法传入索引值，而是调用了 _openCursor_ 来打开一个指针，并且让指针指向满足索引值的数据，之后和前面一样，符合要求的数据推入到 _list_ 数组，最后返回 _list_ 数组。

当然，你可能很好奇 _IDBKeyRange_ 的 _only_ 方法是什么意思，除了 _only_ 方法还有其他方法么？

_IDBKeyRange_ 对象代表数据仓库（_object store_）里面的一组主键。根据这组主键，可以获取数据仓库或索引里面的一组记录。

_IDBKeyRange_ 可以只包含一个值，也可以指定上限和下限。它有四个静态方法，用来指定主键的范围。

- _IDBKeyRange.lowerBound( )_：指定下限。

- _IDBKeyRange.upperBound( )_：指定上限。

- _IDBKeyRange.bound( )_：同时指定上下限。

- _IDBKeyRange.only( )_：指定只包含一个值。

下面是一些代码实例。

```js
// All keys ≤ x
var r1 = IDBKeyRange.upperBound(x);

// All keys < x
var r2 = IDBKeyRange.upperBound(x, true);

// All keys ≥ y
var r3 = IDBKeyRange.lowerBound(y);

// All keys > y
var r4 = IDBKeyRange.lowerBound(y, true);

// All keys ≥ x && ≤ y
var r5 = IDBKeyRange.bound(x, y);

// All keys > x &&< y
var r6 = IDBKeyRange.bound(x, y, true, true);

// All keys > x && ≤ y
var r7 = IDBKeyRange.bound(x, y, true, false);

// All keys ≥ x &&< y
var r8 = IDBKeyRange.bound(x, y, false, true);

// The key = z
var r9 = IDBKeyRange.only(z);
```

例如我们来查询年龄大于 _4_ 岁的学生，其代码片段如下：

```js
function cursorGetDataByIndex(db, storeName, indexName, indexValue) {
    return new Promise((resolve, reject) => {
        ...
        var request = store
            .index(indexName) // 索引对象
            .openCursor(IDBKeyRange.lowerBound(indexValue, true)); // 指针对象
        ...
    })

}
```

利用索引和游标结合查询，我们可以查询出索引值满足我们传入函数值的所有数据对象，而不是只查询出一条数据或者所有数据。

_IndexedDB_ 分页查询不像 _MySQL_ 分页查询那么简单，没有提供现成的 _API_，如 _limit_ 等，所以需要我们自己实现分页。

```js
/**
 * 通过索引和游标分页查询记录
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} indexName 索引名称
 * @param {string} indexValue 索引值
 * @param {number} page 页码
 * @param {number} pageSize 查询条数
 */
function cursorGetDataByIndexAndPage(db, storeName, indexName, indexValue, page, pageSize) {
  return new Promise((resolve, reject) => {
    var list = [];
    var counter = 0; // 计数器
    var advanced = true; // 是否跳过多少条查询
    var store = db.transaction(storeName, 'readwrite').objectStore(storeName); // 仓库对象
    var request = store
      // .index(indexName) // 索引对象
      // .openCursor(IDBKeyRange.only(indexValue)); // 按照指定值分页查询（配合索引）
      .openCursor(); // 指针对象
    request.onsuccess = function (e) {
      var cursor = e.target.result;
      if (page > 1 && advanced) {
        advanced = false;
        cursor.advance((page - 1) * pageSize); // 跳过多少条
        return;
      }
      if (cursor) {
        // 必须要检查
        list.push(cursor.value);
        counter++;
        if (counter < pageSize) {
          cursor.continue(); // 遍历了存储对象中的所有内容
        } else {
          cursor = null;
          resolve(list);
        }
      } else {
        resolve(list);
      }
    };
    request.onerror = function (e) {};
  });
}
```

这里用到了 _IndexedDB_ 的一个 _API_：_advance_。

该函数可以让我们的游标跳过多少条开始查询。假如我们的额分页是每页 _5_ 条数据，现在需要查询第 _2_ 页，那么我们就需要跳过前面 _5_ 条数据，从第 _6_ 条数据开始查询，直到计数器等于 _5_，那么我们就关闭游标，结束查询。

下面在 _index.html_ 中进行测试如下：

```html
<body>
  <script src="./db.js"></script>
  <script>
    openDB('stuDB', 1)
      .then((db) => {
        addData(db, 'stu', { stuId: 5, stuName: '张三', stuAge: 23 });
        addData(db, 'stu', { stuId: 6, stuName: '李四', stuAge: 24 });
        addData(db, 'stu', { stuId: 7, stuName: '王武', stuAge: 32 });
        addData(db, 'stu', { stuId: 8, stuName: '刘德华', stuAge: 34 });
        addData(db, 'stu', { stuId: 9, stuName: '张学友', stuAge: 28 });
        addData(db, 'stu', { stuId: 10, stuName: '郭富城', stuAge: 27 });
        addData(db, 'stu', { stuId: 11, stuName: '黎明', stuAge: 17 });
        addData(db, 'stu', { stuId: 12, stuName: '邓超', stuAge: 19 });
        addData(db, 'stu', { stuId: 13, stuName: '刘翔', stuAge: 15 });
        addData(db, 'stu', { stuId: 14, stuName: '洋洋', stuAge: 12 });
        addData(db, 'stu', { stuId: 15, stuName: '林佳音', stuAge: 14 });
        addData(db, 'stu', { stuId: 16, stuName: '袁进', stuAge: 34 });
        addData(db, 'stu', { stuId: 17, stuName: '老闫', stuAge: 36 });
        addData(db, 'stu', { stuId: 18, stuName: '沈爷', stuAge: 34 });
        return cursorGetDataByIndexAndPage(db, 'stu', '', '', 3, 5);
      })
      .then((stuInfo) => {
        console.log(stuInfo); // {stuId: 3, stuName: '谢希之', stuAge: 4}
      });
  </script>
</body>
```

在上面的代码中，我们为了实现分页效果，添加了一些数据。然后查询第 _3_ 页的内容。

![image-20211201095452722](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015453.png)

查询结果如下：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015510.png" alt="image-20211201095509714" style="zoom:50%;" />

### 更新数据

_IndexedDB_ 更新数据较为简单，直接使用 _put_ 方法，值得注意的是如果数据库中没有该条数据，则会默认增加该条数据，否则更新。

有些小伙伴喜欢更新和新增都是用 _put_ 方法，这也是可行的。

_db.js_

```js
/**
 * 更新数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {object} data 数据
 */
function updateDB(db, storeName, data) {
  return new Promise((resolve, reject) => {
    var request = db
      .transaction([storeName], 'readwrite') // 事务对象
      .objectStore(storeName) // 仓库对象
      .put(data);

    request.onsuccess = function () {
      resolve({
        status: true,
        message: '更新数据成功',
      });
    };

    request.onerror = function () {
      reject({
        status: false,
        message: '更新数据失败',
      });
    };
  });
}
```

在上面的方法中，我们使用仓库对象的 _put_ 方法来修改数据，所以在调用该方法时，需要传入整条数据对象，特别是主键。因为是通过主键来查询到要修改的数据。

如果传入的数据没有主键，则是一个新增数据的效果。

_index.html_

```js
openDB('stuDB', 1)
  .then((db) => {
    return updateDB(db, 'stu', { stuId: 1, stuName: '谢杰2', stuAge: 19 });
  })
  .then(({ message }) => {
    console.log(message);
  });
```

效果如下：

![image-20211201095532213](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015532.png)

### 删除数据

删除数据这里记录 _2_ 种方式，一个是通过主键来进行删除。

_db.js_

```js
/**
 * 通过主键删除数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {object} id 主键值
 */
function deleteDB(db, storeName, id) {
  return new Promise((resolve, reject) => {
    var request = db.transaction([storeName], 'readwrite').objectStore(storeName).delete(id);

    request.onsuccess = function () {
      resolve({
        status: true,
        message: '删除数据成功',
      });
    };

    request.onerror = function () {
      reject({
        status: true,
        message: '删除数据失败',
      });
    };
  });
}
```

_index.html_

```js
openDB('stuDB', 1)
  .then((db) => {
    return deleteDB(db, 'stu', 1);
  })
  .then(({ message }) => {
    console.log(message);
  });
```

执行上面的代码后 _stuId_ 为 _1_ 的学生被删除掉。

有时候我们拿不到主键值，只能只能通过索引值来删除。通过这种方式，我们可以删除一条数据（索引值唯一）或者所有满足条件的数据（索引值不唯一）。

_db.js_

```js
/**
 * 通过索引和游标删除指定的数据
 * @param {object} db 数据库实例
 * @param {string} storeName 仓库名称
 * @param {string} indexName 索引名
 * @param {object} indexValue 索引值
 */
function cursorDelete(db, storeName, indexName, indexValue) {
  return new Promise((resolve, reject) => {
    var store = db.transaction(storeName, 'readwrite').objectStore(storeName);
    var request = store
      .index(indexName) // 索引对象
      .openCursor(IDBKeyRange.only(indexValue)); // 指针对象
    request.onsuccess = function (e) {
      var cursor = e.target.result;
      var deleteRequest;
      if (cursor) {
        deleteRequest = cursor.delete(); // 请求删除当前项
        deleteRequest.onsuccess = function () {
          console.log('游标删除该记录成功');
          resolve({
            status: true,
            message: '游标删除该记录成功',
          });
        };
        deleteRequest.onerror = function () {
          reject({
            status: false,
            message: '游标删除该记录失败',
          });
        };
        cursor.continue();
      }
    };
    request.onerror = function (e) {};
  });
}
```

_index.html_

```js
openDB('stuDB', 1)
  .then((db) => {
    return cursorDelete(db, 'stu', 'stuName', '雅静');
  })
  .then(({ message }) => {
    console.log(message);
  });
```

在上面的示例中，我们就删除了所有 _stuName_ 值为 “雅静” 的同学。

---

以上，就是关于 _IndexedDB_ 的基本操作。

可以看到，在了解了它的几个基本概念后，上手还是比较容易的。

另外由于 _IndexedDB_ 所提供的原生 _API_ 比较复杂，所以现在也出现了基于 _IndexedDB_ 封装的库。例如 _Dexie.js_。

![image-20211201095555138](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-01-015556.png)

（图为 _Dexie.js_ 官网部分截图）

_Dexie.js_ 官网：*https://dexie.org/*

该库和 _IndexedDB_ 之间的关系，就类似于 _jQuery_ 和 _JavaScript_ 之间的关系。有兴趣的同学可以自行进行研究，这里就不再做过多的赘述。

如果想了解 _IndexedDB_ 相关的更多 _API_，可以扩展阅读：*https://www.wangdoc.com/javascript/bom/indexeddb.html*

---

## _File API_

本文主要包含以下内容：

- _File API_ 介绍
- _File_ 对象
  - 构造函数
  - 实例属性和实例方法
- _FileList_ 对象
- _FileReader_ 对象
- 综合实例

### _File API_ 介绍

我们知道，_HTML_ 的 _input_ 表单控件，其 _type_ 属性可以设置为 _file_，表示这是一个上传控件。

```html
<input type="file" name="" id="" />
```

选择文件前：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-02-022039.png" alt="image-20211202102038796" style="zoom:50%;" />

选择文件后：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-02-022057.png" alt="image-20211202102056757" style="zoom:50%;" />

这种做法用户体验非常的差，我们无法**在客户端**对用户选取的文件进行 _validate_，无法读取文件大小，无法判断文件类型，无法预览。

如果是多文件上传，_JavaScript_ 更是回天乏力。

```html
<input type="file" name="" id="" multiple />
```

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-02-022115.png" alt="image-20211202102115626" style="zoom:50%;" />

但现在有了 _HTML5_ 提供的 _File API_，一切都不同了。该接口允许 _JavaScript_ 读取本地文件，但并不能直接访问本地文件，而是要依赖于用户行为，比如用户在 _type='file'_ 控件上选择了某个文件或者用户将文件拖拽到浏览器上。

_File Api_ 提供了以下几个接口来访问本地文件系统：

- _File_：单个文件，提供了诸如 _name、file size、mimetype_ 等只读文件属性

- _FileList_：一个类数组 _File_ 对象集合

- _FileReader_：异步读取文件的接口

- _Blob_：文件对象的二进制原始数据

### _File_ 对象

_File_ 对象代表一个文件，用来读写文件信息。它继承了 _Blob_ 对象，或者说是一种特殊的 _Blob_ 对象，所有可以使用 _Blob_ 对象的场合都可以使用它。

最常见的使用场合是表单的文件上传控件（\<_input type="file"_>），用户选中文件以后，浏览器就会生成一个数组，里面是每一个用户选中的文件，它们都是 _File_ 实例对象。

```html
<input type="file" name="" id="file" />
```

```js
// 获取 DOM 元素
var file = document.getElementById('file');
file.onchange = function (event) {
  var files = event.target.files;
  console.log(files);
  console.log(files[0] instanceof File);
};
```

上面代码中，_files[0]_ 是用户选中的第一个文件，它是 _File_ 的实例。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-02-022135.png" alt="image-20211202102135071" style="zoom:50%;" />

#### 构造函数

浏览器原生提供一个 _File( )_ 构造函数，用来生成 _File_ 实例对象。

```js
new File(array, name [, options])
```

_File( )_ 构造函数接受三个参数。

- _array_：一个数组，成员可以是二进制对象或字符串，表示文件的内容。

- _name_：字符串，表示文件名或文件路径。

- _options_：配置对象，设置实例的属性。该参数可选。

第三个参数配置对象，可以设置两个属性。

- _type_：字符串，表示实例对象的 _MIME_ 类型，默认值为空字符串。

- _lastModified_：时间戳，表示上次修改的时间，默认为 _Date.now( )_。

下面是一个例子。

```js
var file = new File(['foo'], 'foo.txt', {
  type: 'text/plain',
});
```

#### 实例属性和实例方法

_File_ 对象有以下实例属性。

- _File.lastModified_：最后修改时间

- _File.name_：文件名或文件路径

- _File.size_：文件大小（单位字节）

- _File.type_：文件的 _MIME_ 类型

```js
var file = new File(['foo'], 'foo.txt', {
  type: 'text/plain',
});
console.log(file.lastModified); // 1638340865992
console.log(file.name); // foo.txt
console.log(file.size); // 3
console.log(file.type); // text/plain
```

在上面的代码中，我们创建了一个 _File_ 文件对象实例，并打印出了该文件对象的诸如 _lastModified、name、size、type_ 等属性信息。

_File_ 对象没有自己的实例方法，由于继承了 _Blob_ 对象，因此可以使用 _Blob_ 的实例方法 _slice( )_。

### _FileList_ 对象

_FileList_ 对象是一个类似数组的对象，代表一组选中的文件，每个成员都是一个 _File_ 实例。

在最上面的那个示例中，我们就可以看到触发 _change_ 事件后，_event.target.files_ 拿到的就是一个 _FileList_ 实例对象。

它主要出现在两个场合。

- 文件控件节点（\<_input type="file"_>）的 _files_ 属性，返回一个 _FileList_ 实例。

- 拖拉一组文件时，目标区的 _DataTransfer.files_ 属性，返回一个 _FileList_ 实例。

```html
<body>
  <input type="file" name="" id="file" />
  <script>
    // 获取 DOM 元素
    var file = document.getElementById('file');
    file.onchange = function (event) {
      var files = event.target.files;
      console.log(files);
      console.log(files instanceof FileList);
    };
  </script>
</body>
```

上面代码中，文件控件的 _files_ 属性是一个 _FileList_ 实例。

_FileList_ 的实例属性主要是 _length_，表示包含多少个文件。

_FileList_ 的实例方法主要是 _item( )_，用来返回指定位置的实例。它接受一个整数作为参数，表示位置的序号（从零开始）。

但是，由于 _FileList_ 的实例是一个类似数组的对象，可以直接用方括号运算符，即 _myFileList[0]_ 等同于 _myFileList.item(0)_，所以一般用不到 _item( )_ 方法。

### _FileReader_ 对象

_FileReader_ 对象用于读取 _File_ 对象或 _Blob_ 对象所包含的文件内容。

浏览器原生提供一个 _FileReader_ 构造函数，用来生成 _FileReader_ 实例。

```js
var reader = new FileReader();
```

_FileReader_ 有以下的实例属性。

- _FileReader.error_：读取文件时产生的错误对象

- _FileReader.readyState_：整数，表示读取文件时的当前状态。一共有三种可能的状态，_0_ 表示尚未加载任何数据，_1_ 表示数据正在加载，_2_ 表示加载完成。

- _FileReader.result_：读取完成后的文件内容，有可能是字符串，也可能是一个 _ArrayBuffer_ 实例。

- _FileReader.onabort_：_abort_ 事件（用户终止读取操作）的监听函数。

- _FileReader.onerror_：_error_ 事件（读取错误）的监听函数。

- _FileReader.onload_：_load_ 事件（读取操作完成）的监听函数，通常在这个函数里面使用 _result_ 属性，拿到文件内容。

- _FileReader.onloadstart_：_loadstart_ 事件（读取操作开始）的监听函数。

- _FileReader.onloadend_：_loadend_ 事件（读取操作结束）的监听函数。

- _FileReader.onprogress_：_progress_ 事件（读取操作进行中）的监听函数。

下面是监听 _load_ 事件的一个例子。

```html
<body>
  <input type="file" name="" id="file" />
  <script>
    // 获取 DOM 元素
    var file = document.getElementById('file');
    file.onchange = function (event) {
      var file = event.target.files[0]; // 拿到第一个文件
      var reader = new FileReader(); // 创建一个 FileReader 实例对象
      // 读取文件成功后触发 load 事件
      reader.onload = function (event) {
        console.log(event.target.result);
      };
      // 读取文件
      reader.readAsText(file);
    };
  </script>
</body>
```

上面代码中，每当文件控件发生变化，就尝试读取第一个文件。如果读取成功（ _load_ 事件发生），就打印出文件内容。

_FileReader_ 有以下实例方法。

- _FileReader.abort( )_：终止读取操作，_readyState_ 属性将变成 _2_。

- _FileReader.readAsArrayBuffer( )_：以 _ArrayBuffer_ 的格式读取文件，读取完成后 _result_ 属性将返回一个 _ArrayBuffer_ 实例。

- _FileReader.readAsBinaryString( )_：读取完成后，_result_ 属性将返回原始的二进制字符串。

- _FileReader.readAsDataURL( )_：读取完成后，_result_ 属性将返回一个 _Data URL_ 格式（ _Base64_ 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于 \<_img_> 元素的 _src_ 属性。注意，这个字符串不能直接进行 _Base64_ 解码，必须把前缀 `data:*/*;base64,` 从字符串里删除以后，再进行解码。

- _FileReader.readAsText( )_：读取完成后，_result_ 属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 _Blob_ 实例，第二个参数是可选的，表示文本编码，默认为 _UTF-8_。

下面是一个读取图片文件的例子。

```html
<input type="file" name="" id="file" /> <img src="" alt="" width="200" />
```

```js
// 获取 DOM 元素
var file = document.getElementById('file');
file.onchange = function () {
  var preview = document.querySelector('img');
  var file = document.querySelector('input[type=file]').files[0];
  var reader = new FileReader();

  reader.addEventListener(
    'load',
    function () {
      preview.src = reader.result;
    },
    false,
  );

  if (file) {
    reader.readAsDataURL(file);
  }
};
```

上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 _Data URL_ 赋值给 \<_img_> 元素的 _src_ 属性，从而把图片展示出来。

### 综合实例

最后，我们通过一个综合实例来贯穿上面所学的内容。

_HTML_

```html
<label>
  <input type="file" name="" id="file" />
  <div class="uploadImg">
    <!-- 制作中间的十字架 -->
    <div class="cross"></div>
  </div>
</label>
```

_CSS_

```css
.uploadImg {
  position: relative;
  width: 150px;
  height: 150px;
  border: 1px dashed skyblue;
  border-radius: 30px;
  cursor: pointer;
}

.cross {
  position: absolute;
  top: calc(50% - 15px);
  left: calc(50% - 15px);
  width: 30px;
  height: 30px;
}

.cross::before {
  position: absolute;
  top: calc(50% - 1px);
  width: 30px;
  height: 2px;
  background-color: skyblue;
  content: '';
}

.cross::after {
  position: absolute;
  top: calc(50% - 1px);
  left: calc(50% - 15px);
  width: 30px;
  height: 2px;
  background-color: skyblue;
  transform: rotate(90deg);
  content: '';
}

input[type='file'] {
  display: none;
}
```

_JS_

```js
var file = document.querySelector('#file');
var div = document.querySelector('.uploadImg');
var cross = document.querySelector('.cross');
console.log(div.firstChild);
file.onchange = function () {
  // 创建 filereader 用来读取文件
  var reader = new FileReader();
  // 获取到文件内容
  var content = file.files[0];
  if (content) {
    reader.readAsDataURL(content);
  }
  reader.onload = function () {
    // 设置 div 背景图像从而实现预览效果
    div.style.background = `url(${reader.result}) center/cover no-repeat`;
    cross.style.opacity = 0;
  };
};
```

### _File System Access API_

看上去上面的 _File API_ 还不错，能够读取到本地的文件，但是它和离线存储有啥关系？

我们要的是离线存储功能，能够将数据存储到本地。

嗯，确实 _File API_ 只能够做读取的工作，但是有一套新的 _API_ 规范又推出来了，叫做 _File System Access API_。

是的，你没有听错，这是**两套规范**，千万没弄混淆了。

- _File API_ 规范：*https://w3c.github.io/FileAPI/*

- _File System Access API_ 规范：*https://wicg.github.io/file-system-access/*

关于 _File System Access API_，这套方案应该是未来的主角。它提供了比较稳妥的本地文件交互模式，即保证了实用价值，又保障了用户的数据安全。

这个 _API_ 对前端来说意义不小。有了这个功能，_Web_ 可以提供更完整的功能链路，从打开、到编辑、到保存，一套到底。不过遗憾的是目前只有 _Chrome_ 支持。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-12-02-022204.png" alt="image-20211202102203944" style="zoom:50%;" />

（图为该 _API_ 目前在各大浏览器的支持情况，可以看到全线飙红）

目前针对该 _API_ 的相关资料，无论是中文还是英文都比较少，如果对该 API 感兴趣的同学，下面给出两个扩展阅读资料（英文）

- _MDN_：*https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API*

- _web.dev_：*https://web.dev/file-system-access/*

---
